<!doctype html>
<html>
<head>
	<title>채팅 읽어주는 로봇</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-beta/css/bootstrap.min.css">
	<script src="https://cdn.rawgit.com/Skhmt/tapic/5.0.2/dist/tapic.min.js"></script>
	<script src="https://cdn.rawgit.com/blueimp/JavaScript-MD5/v2.10.0/js/md5.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.11.0/alertify.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.11.0/css/alertify.min.css" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.11.0/css/themes/bootstrap.min.css" />
</head>
<body>
	<div id="chat" style="overflow: hidden; word-wrap: break-word; height: 800px; width: 800px;">
		<button type="button" class="btn btn-danger" disabled="disabled" id="btn-cancel" onclick="window.speechSynthesis.cancel();playText('큐를 비웠습니다',1.3,false,'SYSTEM')">초기화중</button>
		<button type="button" class="btn btn-warning" onclick="localStorage.setItem('oauth','');location.reload();" id="btn-logout" disabled="disabled">로그아웃</button><br />
		<div id="last_read"></div>
	</div>
	<script>
		// 트위치 개발자 사이트에서 앱 등록으로 client id를 발급받으실수 있습니다.
		window.oauth_client_id = "bz5whp3i3ihi98e6e1jx3jkxnksyk1";

		// 인증후 돌아올 페이지(현재 페이지 주소)를 입력합니다.
		window.oauth_redirect_uri = "https://lastorder-dc.github.io/chatreader-kor/speech.html";
		
		// ==================================
		// !! 이 아래로는 수정하지 마세요! !!
		// ==================================
		/**
		 * 정규식 특수문자 이스케이프 함수
		 * @param {String} str
		 * @returns {String}
		 */
		function escapeRegExp(str) {
			return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
		}

		/**
		 * 트위치 이모티콘을 공백으로 치환
		 * @param {String} str
		 * @returns {String} message without twitch emoticon
		 */
		function replaceTwitchEmoticon(message, emotes) {
			var ranges;
			var id;
			var emote_id;
			var regExp;
			var replace_list = {};

			if (typeof emotes != 'undefined') {
				var emote_list = emotes.split("/");
				emote_list.forEach(function(emote_replace) {
					ranges = emote_replace.split(":");
					id = ranges[0];
					if (typeof ranges[1] == 'undefined') return;
					ranges = ranges[1].split(",");
					if (typeof ranges[0] != 'undefined') {
						ranges = ranges[0].split("-");
						emote_id = message.substring(parseInt(ranges[0]), parseInt(ranges[1]) + 1);
						replace_list[emote_id] = id;
					}
				});

				for (var replace_id in replace_list) {
					regExp = new RegExp(escapeRegExp(replace_id), "g");
					message = message.replace(regExp, "");
				}
			}

			return message;
		}

		/**
		 * 주소의 GET 인자를 가져오는 함수
		 * @param {String} name 가져올 GET인자 이름
		 * @param {String} address (OPTIONAL) GET인자를 추출할 주소
		 * @returns {String} GET인자 값
		 */
		function getParams(name, address) {
			var url = "";
			var results = "";

			if (typeof address === 'undefined') {
				address = window.location.href;
			}

			url = new URL(address);
			if (typeof url.searchParams === 'undefined') {
				results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(address);
				if (results == null) {
					return null;
				} else {
					return decodeURI(results[1]) || 0;
				}
			} else {
				return url.searchParams.get(name);
			}
		}

		var url_string = window.location.href;
		var url = new URL(url_string);
		
		if('speechSynthesis' in window) {
			if(speechSynthesis.getVoices().length === 0) {
				location.href = "./no_tts.html";
			}
		} else {
			location.href = "./no_tts.html";
		}

		// 주소뒤 ?channel=(채널아이디) 로 지정
		window.channelname = getParams("channel");

		if (window.channelname === null) window.channelname = "";

		// oauth token으로 처음 페이지 접속시 트위치 로그인으로 생성함(로컬스토리지 저장, 로그아웃시 초기화됨)
		window.oauth = localStorage.getItem("oauth") !== null ? localStorage.getItem("oauth") : "";

		// 주소뒤 ?debug=true 로 디버그모드 활성화
		window.debugmode = getParams("debug") === "true" ? true : false;

		// 읽을 채팅 최대 길이(!!tts maxlength (길이)로 변경가능)
		window.maxlength = localStorage.getItem("tts_maxlength") !== null ? parseInt(localStorage.getItem("tts_maxlength")) : 40;

		// 밴리스트(로컬스토리지 저장, !!tts ban (아이디) 로 밴하고 !!tts unban (아이디)로 밴 해제)
		window.banlist = localStorage.getItem("tts_banlist_" + window.channelname) !== null ? localStorage.getItem("tts_banlist_" + window.channelname).split("|") : [];

		// 밴키워드(로컬스토리지 저장, !!tts ban (아이디) 로 밴하고 !!tts unban (아이디)로 밴 해제)
		window.bankeyword = localStorage.getItem("tts_bankeyword_" + window.channelname) !== null ? localStorage.getItem("tts_bankeyword_" + window.channelname).split("|") : [];

		// 기본적으로 밴할 리스트
		window.banlist = window.banlist.concat(['Nightbot', '싹둑']);

		// 기본적으로 밴할 키워드
		window.bankeyword = window.bankeyword.concat(['섹스']);

		// 초기화 성공 여부
		window.initok = false;

		window.mod_speed = 1;
		window.nonmod_speed = 1.2;

		alertify.defaults.transition = "slide";
		alertify.defaults.theme.ok = "btn btn-primary";
		alertify.defaults.theme.cancel = "btn btn-danger";
		alertify.defaults.theme.input = "form-control";
		alertify.set('notifier', 'position', 'top-center');

		speechSynthesis.cancel();

		if (window.oauth != "") {
			// You have to run .setup() before anything besides .listen()
			TAPIC.setup(window.oauth, function(username) {
				TAPIC.setRefreshRate(10);

				if (window.channelname == "") {
					document.body.innerHTML = '';
					alertify.prompt('채널 아이디 입력', '연결할 채널 아이디를 입력해주세요. 한글 닉네임 대신 twitch.tv/ 주소 뒤에 붙는 영문 아이디를 입력해주셔야 합니다.', '', function(evt, value) {
						if (value == "") {
							alertify.error('채널명이 비어있으므로 동작할 수 없습니다.');
						} else {
							window.channelname = value;
							location.href = url.origin + url.pathname + "?channel=" + value;
						}
					}, function() {
						alertify.error('채널명이 비어있으므로 동작할 수 없습니다.');
					}).set({
						'closableByDimmer': false
					});
				} else {
					TAPIC.joinChannel(window.channelname, function() {
						if ('speechSynthesis' in window) {
							window.korSupport = false;
							window.utterances = [];

							var msg = new SpeechSynthesisUtterance(window.channelname + " 채널에 연결되었습니다.");
							msg.rate = 1.3;
							speechSynthesis.cancel();

							msg.onend = function(event) {
								var voices = speechSynthesis.getVoices();

								if (voices.length == 0) {
									alert("사용 가능한 TTS DB 없음");
								} else {
									speechSynthesis.getVoices().forEach(function(voice) {
										if (voice.lang == "ko_KR" || voice.lang == "ko-KR" || voice.lang == "kr" || voice.lang == "ko") window.korSupport = true;
									});

									if (!window.korSupport) {
										alert("한글 미지원으로 사용 불가능");
									} else {
										window.initok = true;
									}
								}

								document.getElementById("btn-cancel").disabled = false;
								document.getElementById("btn-cancel").innerHTML = "큐 비우기";
								document.getElementById("btn-logout").disabled = false;
							};

							utterances.push(msg);
							window.speechSynthesis.speak(msg);
						} else {
							alert("TTS API 미지원으로 사용 불가능");
						}
					});
				}
			});

			TAPIC.listen('message', function(e) {
				if ((e.mod || e.streamer || e.badges.indexOf("broadcaster/1") != -1) && e.text.match(/!!tts /) !== null) {
					var command = e.text.replace("!!tts ", "");
					if (command !== "") {
						if (command.indexOf("maxlength ") !== -1) {
							command = command.replace("maxlength ", "");
							if (parseInt(command) > 0) {
								window.maxlength = parseInt(command);
								if (window.maxlength > 120) window.maxlength = 120;
								localStorage.setItem("tts_maxlength", window.maxlength.toString());
								TAPIC.sendChat("/me [TTSBOT] 최대 TTS 글자수가 " + window.maxlength.toString() + "글자로 바뀌었습니다.");
							}
						}

						if (command.indexOf("unban ") !== -1) {
							command = command.replace("unban ", "");
							if (command != "") {
								var index = window.banlist.indexOf(command);
								if (index !== -1) {
									window.banlist.splice(index, 1);
									localStorage.setItem("tts_banlist_" + window.channelname, window.banlist.join("|"));
									TAPIC.sendChat("/me [TTSBOT] 시청자 " + command + " 를 차단 해제했습니다.");
								} else {
									TAPIC.sendChat("/me [TTSBOT] 시청자 " + command + " 는 차단되어 있지 않습니다.");
								}
							}
						} else {
							if (command.indexOf("ban ") !== -1) {
								command = command.replace("ban ", "");
								if (command != "") {
									var index = window.banlist.indexOf(command);
									if (index === -1) {
										window.banlist.push(command);
										localStorage.setItem("tts_banlist_" + window.channelname, window.banlist.join("|"));
										TAPIC.sendChat("/me [TTSBOT] 시청자 " + command + " 를 차단했습니다.");
									} else {
										TAPIC.sendChat("/me [TTSBOT] 시청자 " + command + " 은 이미 차단되어 있습니다.");
									}
								}
							}
						}

						if (command.indexOf("del ") !== -1) {
							command = command.replace("del ", "");
							if (command != "") {
								var index = window.bankeyword.indexOf(escapeRegExp(command));
								if (index !== -1) {
									window.bankeyword.splice(index, 1);
									localStorage.setItem("tts_bankeyword_" + window.channelname, window.bankeyword.join("|"));
									TAPIC.sendChat("/me [TTSBOT] 키워드 " + command + " 를 차단 해제했습니다.");
								} else {
									TAPIC.sendChat("/me [TTSBOT] 시청자 " + command + " 는 차단되어 있지 않습니다.");
								}
							}
						} else {
							if (command.indexOf("add ") !== -1) {
								command = command.replace("add ", "");
								if (command != "") {
									var index = window.bankeyword.indexOf(escapeRegExp(command));
									if (index === -1) {
										window.bankeyword.push(escapeRegExp(command));
										localStorage.setItem("tts_bankeyword_" + window.channelname, window.bankeyword.join("|"));
										TAPIC.sendChat("/me [TTSBOT] 키워드 " + command + " 를 차단했습니다.");
									} else {
										TAPIC.sendChat("/me [TTSBOT] 키워드 " + command + " 은 이미 차단되어 있습니다.");
									}
								}
							}
						}
					}
				} else {
					// 초기화 후에만 읽음
					if (window.initok) {
						var index = window.banlist.indexOf(e.from);
						var message = e.text;
						var keyword_test = new RegExp("(" + window.bankeyword.join("|") + ")", "g");

						// Personality 적용
						var personality_range1 = [1, 1.4];
						var personality_range2 = [0.9, 1.2];

						var personality_int1 = 0,
							personality_int2 = 0;

						// 금지단어 포함 메세지 전체 읽지 않음
						if (keyword_test.test(message)) return;

						for (var i = 0; i < e.from.length; i++) {
							personality_int1 += e.from.charCodeAt(i);
							personality_int2 |= e.from.charCodeAt(i);
						}
						personality_int1 %= ((personality_range1[1] * 10 - personality_range1[0] * 10) + 1);
						personality_int2 %= ((personality_range2[1] * 10 - personality_range2[0] * 10) + 1);

						var personality_speed = 1 + (personality_int1 / 10) - (1 - personality_range1[0]);
						if (personality_speed < 0.8) personality_speed = window.nonmod_speed;
						personality_speed = Math.min(personality_speed, personality_range1[1]);

						var personality_pitch = 1 + (personality_int2 / 10) - (1 - personality_range2[0]);
						if (personality_pitch < 0.8) personality_pitch = window.nonmod_speed;
						personality_pitch = Math.min(personality_pitch, personality_range2[1]);

						// 메세지 필터링
						// 링크는 "링크"로 읽음
						message = message.replace(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g, "링크");

						// ? [ ] { } ( )는 읽지 않음
						message = message.replace(/[\[\]\(\)\{\}]/g, "");

						// &~~~;와 같은 엔티티 문자는 읽지 않음
						message = message.replace(/&(.*?);/g, "");

						// 이모지는 읽지 않음
						message = message.replace(/\ud83d[\ude00-\ude4f]/g, "");

						// ?는 한번만 읽음
						message = message.replace(/\?{2,}/g, "?");

						// 물결표는 한번만 읽음
						message = message.replace(/~{2,}/g, "~");

						// ㅋ이 3번 이상 있으면 3번만 읽음
						message = message.replace(/ㅋ{3,}/g, "ㅋㅋㅋ");

						// 이외 모든 글자가 4번 이상 연속으로 있으면 삭제(읽지 않음)
						message = message.replace(/(.)\1{3,}/g, "");

						// !로 시작하는 메세지는 읽지 않음
						message = message.replace(/^!.*/g, "");

						// /me 명령어 입력시 나타나는 맨 마지막 \x01 제거
						if (message.charCodeAt(message.length - 1) === 1) message = message.substr(0, message.length - 1);

						// 트위치 이모티콘은 읽지 않음
						message = replaceTwitchEmoticon(message, e.emotes);

						if (message != "") {
							// 모더레이터/스트리머는 설정 무관 최대 120글자 읽기 가능
							if (((e.mod && index < 0) || e.streamer || e.badges.indexOf("broadcaster/1") != -1) && message.length < 120) {
								playText(message, personality_speed, personality_pitch, false, e.from);
							} else {
								// 밴리스트에 없는 아이디면서 채팅 길이가 지정된 길이 미만
								if (index === -1 && message.length < window.maxlength) {
									playText(message, personality_speed, personality_pitch, false, e.from);
								}
							}
						}
					}
				}
			});

			function playText(string, speed, pitch, ignoreKor, nickname) {
				if ('speechSynthesis' in window) {
					var i = 0;
					var google_kor = -1;
					var google_jpn = -1;
					var check = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/;
					var check_jp = /[\u3040-\u30ff\u31f0-\u31ff]/;

					speechSynthesis.getVoices().forEach(function(voice) {
						if (check.test(string)) {
							if (voice.lang == "ko_KR" || voice.lang == "ko-KR" || voice.lang == "kr" || voice.lang == "ko") window.korSupport = true;
							if (voice.lang == "ko-KR" && voice.name.indexOf("Google") !== -1) {
								google_kor = i;
							}
						} else if (check_jp.test(string)) {
							if (voice.lang == "ja_JP" || voice.lang == "ja-JP" || voice.lang == "jp" || voice.lang == "ja") window.jpnSupport = true;
							if (voice.lang == "ja-JP" && voice.name.indexOf("Google") !== -1) {
								google_jpn = i;
							}
						} else {
							if (voice.lang == "en-US" && voice.name.indexOf("Google") !== -1) {
								google_kor = i;
							}
						}

						i++;
					});

					if (window.korSupport || ignoreKor) {
						var msg = new SpeechSynthesisUtterance(string);

						if (check.test(string)) msg.lang = "ko-KR";
						else if (check_jp.test(string)) msg.lang = "ja-JP";
						else msg.lang = "en-US";
						msg.from = nickname;
						if (google_kor !== -1) msg.voice = speechSynthesis.getVoices()[google_kor];
						else if (google_jpn !== -1) msg.voice = speechSynthesis.getVoices()[google_jpn];
						msg.rate = speed;
						msg.pitch = pitch;
						msg.onstart = function(event) {
							if (typeof event.utterance.from == "undefined" || event.utterance.from == "") event.utterance.from = "Unknown";
							document.getElementById("last_read").innerHTML = "<b>" + event.utterance.from + "</b>:" + event.utterance.text;
						}
						msg.onend = function(event) {
							if (window.debugmode) console.log("msg read event");
							if (window.debugmode) console.log(event);
						}
						window.speechSynthesis.speak(msg);
					}
				}
			}
		} else {
			// there's no oauth key
			if (document.location.hash != "" && document.location.hash.indexOf("access_token") !== -1) {
				//user already authed
				var rawauth = document.location.href.replace("#", "?");
				var authobj = new URL(rawauth);
				var oauth = getParams("access_token", rawauth);
				var state = getParams("state", rawauth);
				var localstate = localStorage.getItem("state");
				var last_url = localStorage.getItem("last_url");
				var last_url_obj = new URL(last_url);

				document.body.innerHTML = '';

				if (last_url_obj.origin !== authobj.origin) {
					document.write("SECURITY ERROR");
				} else {
					if (localstate === null || localstate === "" || state !== localstate) {
						document.write("잘못된 state값이 전달되었습니다. 페이지를 새로고침 해보세요.<br />Invalid state. please refresh and retry.")
					} else {
						localStorage.setItem("oauth", oauth);
						localStorage.setItem("state", "");
						localStorage.setItem("last_url", "");
						location.href = last_url;
					}
				}
			} else {
				//not authed yet
				var state = md5(Date.now());
				localStorage.setItem("state", state);
				localStorage.setItem("last_url", location.href);

				document.body.innerHTML = '';
				document.write("트위치로 로그인해야 사용하실수 있습니다. <a href=\"https://api.twitch.tv/kraken/oauth2/authorize?response_type=token&client_id=" +
					window.oauth_client_id +
					"&redirect_uri=" +
					window.oauth_redirect_uri +
					"&scope=chat_login%20channel_editor%20channel_commercial%20channel_check_subscription&state=" +
					state +
					"\">로그인</a>");
			}
		}
	</script>
</body>
</html>
